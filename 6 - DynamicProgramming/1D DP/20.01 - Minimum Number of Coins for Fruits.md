### Leetcode - 2944 - [Minimum Number of Coins for Fruits](https://leetcode.com/problems/minimum-number-of-coins-for-fruits/description/)

* TopDown Approach - Without Memoization
```cpp
class TopDown{
public:
    int solveWithoutMemo(vector<int>& prices, int currIdx){
        int n = prices.size() ;
        if(currIdx >= n){
            return 0 ;
        }
        int minCoins = INT_MAX ;
        int jumpLimit = currIdx+1 ;

        for(int jump = 1 ; jump <= jumpLimit ; ++jump){
            int nextBuy = solveWithoutMemo(prices, currIdx + jump) ;        // Consider purchasing the next fruit, hence move to that start point
            int nextFree = solveWithoutMemo(prices, currIdx + jump + 1) ;   // Consider the next fruit for free, hence skip that start point
            int currCoins = prices[currIdx] + min(nextBuy, nextFree) ;
            minCoins = min(minCoins, currCoins) ;
        }
        return minCoins ;
    }

    int minimumCoins(vector<int>& prices) {
        int start = 0 ;
        return solveWithoutMemo(prices, start) ;
    }    
}
```

> Time Complexity = O(2<sup>N</sup>)

> Space Complexity = O(2*N) -- Recursion Stack

---

* TopDown Approach - With Memoization

```cpp
class TopDown{
public:
    int solveWithMemo(vector<int>& prices, int currIdx, int n, vector<int>& dp){
        if(currIdx >= n){
            return 0 ;
        }
        if(dp[currIdx] != -1){
            return dp[currIdx] ;
        }

        int minCoins = INT_MAX ;
        int jumpLimit = currIdx+1 ;

        for(int jump = 1 ; jump <= jumpLimit ; ++jump){
            int nextBuy = solveWithMemo(prices, currIdx + jump, n, dp) ;
            int nextFree = solveWithMemo(prices, currIdx + jump + 1, n, dp) ;
            int currCoins = prices[currIdx] + min(nextBuy, nextFree) ;
            minCoins = min(minCoins, currCoins) ;
        }
        return dp[currIdx] = minCoins ;
    }

    int minimumCoins(vector<int>& prices) {
        int start = 0, n = prices.size() ;
        vector<int> dp(n+1, -1) ;
        return solveWithMemo(prices, start, n, dp) ;
    }
};    
```

> Time Complexity = O(2*N)

> Space Complexity = O(3*N) -- Recursion Stack + Vector 

---

* Bottom Up Approach -- With 1D table

```cpp
class BottomUp{
public:
    int solveWith1DTable(vector<int>& prices){
        int n = prices.size() ;
        vector<int> dp(n+2, -1) ;
        dp[n] = dp[n+1] = 0 ;

        for(int currIdx = n-1 ; currIdx >= 0 ; --currIdx){
            int minCoins = INT_MAX ;
            int jumpLimit = currIdx+1 ;
            for(int jump = 1 ; (jump <= jumpLimit) and ((currIdx + jump + 1) <= (n+1)) ; ++jump){
                int nextBuy = dp[currIdx + jump] ;
                int nextFree = dp[currIdx + jump + 1] ;
                int currCoins = prices[currIdx] + min(nextBuy, nextFree) ;
                minCoins = min(minCoins, currCoins) ;
            }
            dp[currIdx] = minCoins ; 
        }
        return dp[0] ;
    }

    int minimumCoins(vector<int>& prices) {
        return solveWith1DTable(prices) ;
    }
}
```

> Time Complexity = O(N<sup>2</sup>)

> Space Complexity = O(N)

---

* Bottom Up Approach -- Without 1D table

```cpp
class BottomUp{
// Can't be optimized further, b/c of randomness
}
```

> Time Complexity = O()

> Space Complexity = O()