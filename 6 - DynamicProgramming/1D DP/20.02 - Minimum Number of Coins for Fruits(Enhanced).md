### Leetcode - 2944 - [Minimum Number of Coins for Fruits](https://leetcode.com/problems/minimum-number-of-coins-for-fruits/description/)

* TopDown Approach - Without Memoization
```cpp
class TopDown{
    public :
    int solveWithoutMemo(vector<int>& prices, int currIdx){
        int n = prices.size() ;
        if(currIdx >= n){
            return 0 ;
        }

        int jumpLimit = currIdx + 1 ;
        int minCoins = solveWithoutMemo(prices, currIdx + jumpLimit + 1) ;      // We know the total free foods, so skipping all of these at once

        for(int jump = 1 ; i <= jumpLimit ; ++i){
            int nextBuy = solveWithoutMemo(prices, currIdx + jump) ;        // Now consider purchaing next fruit, so go to them
            minCoins = min(minCoins, nextBuy) ;
        }

        return (minCoins + prices[currIdx]) ;
    }

    int minimumCoins(vector<int>& prices){
        int start = 0 ;
        return solveWithoutMemo(prices, start) ;
    }
};
```

> Time Complexity = O(2<sup>N</sup>)

> Space Complexity = O(2*N) -- Recursion Stack

---

* TopDown Approach - With Memoization

```cpp
class TopDown{
    public :
    int solveWithMemo(vector<int>& prices, int currIdx, vector<int>& dp){
        int n = prices.size() ;
        if(currIdx >= n){
            return 0 ;
        }

        if(dp[currIdx] != -1){
            return dp[currIdx] ;
        }

        int jumpLimit = currIdx + 1 ;
        int minCoins = solveWithMemo(prices, currIdx + jumpLimit + 1, dp) ;     // We know the total free foods, so skipping all of these at once

        for(int jump = 1 ; jump <= jumpLimit ; ++jump){
            int nextBuy = solveWithMemo(prices, currIdx + jump, dp) ;   // Now consider purchasing next fruit so go to them
            minCoins = min(minCoins, nextBuy) ;
        }

        return dp[currIdx] = (prices[currIdx] + minCoins) ;
    }

    int minimumCoins(vector<int>& prices){
        int start = 0, n = prices.size() ;
        vector<int> dp(n, -1) ;
        return solveWithMemo(prices, start, dp) ;
    }
};
```

> Time Complexity = O(N+N<sup>2</sup>)

> Space Complexity = O(3*N) -- Recursion Stack + Vector 

---

* Bottom Up Approach -- With 1D table

```cpp
class BottomUp{
    public ;
    int solveWith1DTable(vector<int>& prices){
        int n = prices.size() ;
        vector<int> dp(n+1, -1) ;
        dp[n] = 0 ;

        for(int currIdx = n-1 ; currIdx >= 0 ; --currIdx){
            int jumpLimit = currIdx +1 ;
            int nextIdx = jumpLimit + 1 ;
            int minCoins = (nextIdx <= n) : dp[nextIdx] ? 0 ;
            for(int jump = 1 ; jump <= jumpLimit ; ++jump){
                int nextBuy = dp[currIdx+jump] ;
                minCoins = min(minCoins, nextBuy) ;
            }
            dp[currIdx] = (prices[currIdx] + minCoins) ;
        }
        return dp[0] ;
    }

    int minimumCoins(vector<int>& prices){
        return solveWith1DTable(prices) ;
    }
};
```

> Time Complexity = O(N<sup>2</sup>)

> Space Complexity = O(1*N)

---

* Bottom Up Approach -- Without 1D table

```cpp
class BottomUp{
// Can't be optimized further
};
```

> Time Complexity = O()

> Space Complexity = O()