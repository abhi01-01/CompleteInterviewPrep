### Leetcode - 322 - [Coin Change](https://leetcode.com/problems/coin-change/description/)

* TopDown Approach - Without Memoization
```cpp
class TopDown{
    public:
    int solveWithoutMemo(vector<int>& coins, int amount){
        int n = coins.size() ;

        if(amount == 0){
            return 0 ;
        }

        int minCoins = INT_MAX ;

        for(int path = 0 ; path < n ; ++path){
            if(coins[path] > amount){
                continue ;
            }
            int nextCoin = solveWithoutMemo(coins, amount-coins[path]) ;
            if(nextCoin != INT_MAX){
                minCoins = min(minCoins, nextCoin + 1) ;
            }
        }

        return minCoins ;
    }

    int coinChange(vector<int>& coins, int amount) {
        int minCoins = solveWithoutMemo(coins, amount) ;
        return (minCoins == INT_MAX) ? -1 : minCoins ; 
    }
};
```

> Time Complexity = O(N<sup>A</sup>) where A is the amount

> Space Complexity = O(A) -- Recursion Stack

---

* TopDown Approach - With Memoization

```cpp
class TopDown{
public:
    int solveWithMemo(vector<int>& coins, int amount, vector<int>& dp){
        int n = coins.size() ;

        if(amount == 0){
            return 0 ;
        }

        if(dp[amount] != -1){
            return dp[amount] ;
        }

        int minCoins = INT_MAX ;

        for(int path = 0 ; path < n ; ++path){
            if(coins[path] > amount){
                continue ;
            }
            int nextCoin = solveWithMemo(coins, amount-coins[path], dp) ;
            if(nextCoin != INT_MAX){
                minCoins = min(minCoins, nextCoin + 1) ;
            }
        }

        return dp[amount] = minCoins ;
    }

    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1, -1);
        int minCoins = solveWithMemo(coins, amount, dp) ;
        return (minCoins == INT_MAX) ? -1 : minCoins ; 
    }
};
```

> Time Complexity = O(N*A)

> Space Complexity = O(2*A) -- Recursion Stack + Vector 

---

* Bottom Up Approach -- With 1D table

```cpp
class BottomUp{
public:
    int solveWith1Dtable(vector<int>& coins, int amount){
        int n = coins.size() ;
        vector<int> dp(amount+1, -1) ;
        dp[0] = 0 ;

        for(int i = 1 ; i <= amount ; ++i){
            int minCoins = INT_MAX ;
            for(int path = 0 ; path < n ; ++path){
                if(coins[path] > amount){
                    continue ;
                }
                int nextCoin = ((i-coins[path]) >= 0 ) ? dp[i-coins[path]] : INT_MAX ;
                if(nextCoin != INT_MAX){
                    minCoins = min(minCoins, nextCoin + 1) ;
                }
            }
            dp[i] = minCoins ;
        }
        return dp[amount] ;
    }

    int coinChange(vector<int>& coins, int amount) {
        int minCoins = solveWith1Dtable(coins, amount) ;
        return (minCoins == INT_MAX) ? -1 : minCoins ; 
    }
};
```

> Time Complexity = O(N*A)

> Space Complexity = O(A)

---

* Bottom Up Approach -- Without 1D table

```cpp
class BottomUp{
// Can't be optimized further
};
```

> Time Complexity = O()

> Space Complexity = O()