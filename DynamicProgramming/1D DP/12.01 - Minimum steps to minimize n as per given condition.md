### GFG - [Minimum steps to minimize n as per given condition](https://www.geeksforgeeks.org/problems/minimum-steps-to-minimize-n-as-per-given-condition0618/0)


* TopDown Approach - Without Memoization
```cpp
class TopDown{
  public:
    int solveWithoutMemo(int N){
        if(N <= 1){
            return 0 ; // 0 steps needed
        }
        
        int minSteps = solveWithoutMemo(N-1) ;
        
        if(N%2 == 0){
            minSteps = min(minSteps, solveWithoutMemo(N/2)) ;
        }
        
        if(N%3 == 0){
            minSteps = min(minSteps, solveWithoutMemo(N/3)) ;
        }
        
        return (minSteps + 1);
    }
    
    int minSteps(int N) {
        return solveWithoutMemo(N) ;
    }    
}
```

> Time Complexity = O(3<sup>N</sup>)

> Space Complexity = O(3*N) -- Recursion Stack

---

* TopDown Approach - With Memoization

```cpp
class TopDown{
  public:
    int solveWithMemo(int N, vector<int>& dp){
        if(N <= 1){
            return 0 ; // 0 steps needed
        }
        
        if(dp[N] != -1){
            return dp[N] ;
        }
        
        int minSteps = solveWithMemo(N-1, dp) ;
        
        if(N%2 == 0){
            minSteps = min(minSteps, solveWithMemo(N/2, dp)) ;
        }
        
        if(N%3 == 0){
            minSteps = min(minSteps, solveWithMemo(N/3, dp)) ;
        }
        
        return dp[N] = (minSteps + 1);
    }
    
    int minSteps(int N) {
        vector<int> dp(N+1, -1) ;
        return solveWithMemo(N, dp) ;
    }    
}
```

> Time Complexity = O(3*N)

> Space Complexity = O(4*N) -- Recursion Stack + Vector 

---

* Bottom Up Approach -- With 1D table

```cpp
class BottomUp{
  public:
    int solveWith1Dtable(int N){
        vector<int> dp(N+1, -1) ;
        dp[0] = 0 ;
        // 0 steps needed
        dp[1] = 0 ;
        
        for(int i = 2 ; i <= N ; ++i){
            int minSteps = dp[i-1] ;
            if(i%2 == 0){
                minSteps = min(minSteps, dp[i/2]) ;
            }
            if(i%3 == 0){
                minSteps = min(minSteps, dp[i/3]) ;
            }
            dp[i] = (minSteps + 1);
            
        }
        return dp[N] ;
    }
    
    int minSteps(int N) {
        vector<int> dp(N+1, -1) ;
        return solveWith1Dtable(N) ;
    }
}
```

> Time Complexity = O(1*N)

> Space Complexity = O(1*N)

---

* Bottom Up Approach -- Without 1D table

```cpp
class bottomUp{
// Can't be further optimized
}
```

> Time Complexity = O()

> Space Complexity = O()